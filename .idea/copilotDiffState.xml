<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CMakeLists.txt" />
              <option name="originalContent" value="cmake_minimum_required(VERSION 3.23)&#10;project(VAMCore LANGUAGES CXX)&#10;# === Python Executable Compatibility ===&#10;# If Python3_EXECUTABLE is set but not Python_EXECUTABLE, map it&#10;if(Python3_EXECUTABLE AND NOT Python_EXECUTABLE)&#10;    set(Python_EXECUTABLE ${Python3_EXECUTABLE})&#10;endif()&#10;&#10;set(CMAKE_CXX_STANDARD 23)&#10;set(CMAKE_CXX_STANDARD_REQUIRED ON)&#10;set(CMAKE_CXX_EXTENSIONS OFF)&#10;&#10;&#10;&#10;# Use vendored pybind11 from extern/ directory&#10;add_subdirectory(extern/pybind11)&#10;&#10;# Core VAM library sources&#10;add_library(vamcore STATIC&#10;        src/biot_savart.cpp&#10;        src/fluid_dynamics.cpp&#10;        src/fluid_rotation.cpp&#10;        src/frenet_helicity.cpp&#10;        src/gravity_timefield.cpp&#10;        src/kinetic_energy.cpp&#10;        src/knot_dynamics.cpp&#10;        src/potential_flow.cpp&#10;        src/potential_timefield.cpp&#10;        src/pressure_field.cpp&#10;        src/radiation_flow.cpp&#10;        src/relative_vorticity.cpp&#10;        src/swirl_field.cpp&#10;        src/thermo_dynamics.cpp&#10;        src/time_evolution.cpp&#10;        src/vortex_knot_system.cpp&#10;        src/vortex_ring.cpp&#10;        src/vorticity_dynamics.cpp&#10;        src/vorticity_transport.cpp&#10;)&#10;&#10;target_include_directories(vamcore PUBLIC src)&#10;&#10;# Python bindingsac&#10;pybind11_add_module(vambindings src_bindings/module_vam.cpp)&#10;target_sources(vambindings PRIVATE&#10;        src_bindings/py_biot_savart.cpp&#10;        src_bindings/py_fluid_dynamics.cpp&#10;        src_bindings/py_fluid_rotation.cpp&#10;        src_bindings/py_frenet_helicity.cpp&#10;        src_bindings/py_gravity_timefield.cpp&#10;        src_bindings/py_kinetic_energy.cpp&#10;        src_bindings/py_knot_dynamics.cpp&#10;        src_bindings/py_potential_flow.cpp&#10;        src_bindings/py_potential_timefield.cpp&#10;        src_bindings/py_pressure_field.cpp&#10;        src_bindings/py_radiation_flow.cpp&#10;        src_bindings/py_relative_vorticity.cpp&#10;        src_bindings/py_swirl_field.cpp&#10;        src_bindings/py_thermo_dynamics.cpp&#10;        src_bindings/py_time_evolution.cpp&#10;        src_bindings/py_vortex_knot_system.cpp&#10;        src_bindings/py_vortex_ring.cpp&#10;        src_bindings/py_vorticity_dynamics.cpp&#10;        src_bindings/py_vorticity_transport.cpp)&#10;&#10;target_link_libraries(vambindings PRIVATE vamcore)&#10;target_include_directories(vambindings PRIVATE extern/pybind11/include)&#10;add_executable(test_frenet tests/test_frenet_helicity.cpp)&#10;target_link_libraries(test_frenet PRIVATE vamcore)&#10;&#10;&#10;# Install targets&#10;install(TARGETS vamcore vambindings&#10;        LIBRARY DESTINATION lib&#10;        ARCHIVE DESTINATION lib&#10;        RUNTIME DESTINATION bin)&#10;install(DIRECTORY include/ DESTINATION include)&#10;&#10;# === ✅ AUTO-COPY PYBIND MODULE TO PROJECT ROOT ===&#10;# After vambindings is built, copy it to ${CMAKE_SOURCE_DIR}&#10;# So you can easily import it from Python scripts in the root directory&#10;&#10;add_custom_command(TARGET vambindings POST_BUILD&#10;        COMMAND ${CMAKE_COMMAND} -E copy&#10;        $&lt;TARGET_FILE:vambindings&gt;&#10;        ${CMAKE_SOURCE_DIR}/$&lt;TARGET_FILE_NAME:vambindings&gt;&#10;        COMMAND ${CMAKE_COMMAND} -E copy&#10;        $&lt;TARGET_FILE:vambindings&gt;&#10;        ${CMAKE_SOURCE_DIR}/examples/$&lt;TARGET_FILE_NAME:vambindings&gt;&#10;        COMMAND ${CMAKE_COMMAND} -E copy&#10;        $&lt;TARGET_FILE:vambindings&gt;&#10;        ${CMAKE_SOURCE_DIR}/../VAM/$&lt;TARGET_FILE_NAME:vambindings&gt;&#10;        COMMENT &quot;Copied vambindings module to project root, examples/, and ../VAM/ for easy import&quot;&#10;)&#10;" />
              <option name="updatedContent" value="cmake_minimum_required(VERSION 3.23)&#10;project(VAMCore LANGUAGES CXX)&#10;# === Python Executable Compatibility ===&#10;# If Python3_EXECUTABLE is set but not Python_EXECUTABLE, map it&#10;if(Python3_EXECUTABLE AND NOT Python_EXECUTABLE)&#10;    set(Python_EXECUTABLE ${Python3_EXECUTABLE})&#10;endif()&#10;&#10;set(CMAKE_CXX_STANDARD 23)&#10;set(CMAKE_CXX_STANDARD_REQUIRED ON)&#10;set(CMAKE_CXX_EXTENSIONS OFF)&#10;&#10;&#10;&#10;# Use vendored pybind11 from extern/ directory&#10;add_subdirectory(extern/pybind11)&#10;&#10;# Core VAM library sources&#10;add_library(vamcore STATIC&#10;        src/biot_savart.cpp&#10;        src/fluid_dynamics.cpp&#10;        src/fluid_rotation.cpp&#10;        src/frenet_helicity.cpp&#10;        src/gravity_timefield.cpp&#10;        src/kinetic_energy.cpp&#10;        src/knot_dynamics.cpp&#10;        src/potential_flow.cpp&#10;        src/potential_timefield.cpp&#10;        src/pressure_field.cpp&#10;        src/radiation_flow.cpp&#10;        src/relative_vorticity.cpp&#10;        src/swirl_field.cpp&#10;        src/thermo_dynamics.cpp&#10;        src/time_evolution.cpp&#10;        src/vortex_knot_system.cpp&#10;        src/vortex_ring.cpp&#10;        src/vorticity_dynamics.cpp&#10;        src/vorticity_transport.cpp&#10;        src/FourierKnot.cpp&#10;)&#10;&#10;target_include_directories(vamcore PUBLIC src)&#10;&#10;# Python bindingsac&#10;pybind11_add_module(vambindings src_bindings/module_vam.cpp)&#10;target_sources(vambindings PRIVATE&#10;        src_bindings/py_biot_savart.cpp&#10;        src_bindings/py_fluid_dynamics.cpp&#10;        src_bindings/py_fluid_rotation.cpp&#10;        src_bindings/py_frenet_helicity.cpp&#10;        src_bindings/py_gravity_timefield.cpp&#10;        src_bindings/py_kinetic_energy.cpp&#10;        src_bindings/py_knot_dynamics.cpp&#10;        src_bindings/py_potential_flow.cpp&#10;        src_bindings/py_potential_timefield.cpp&#10;        src_bindings/py_pressure_field.cpp&#10;        src_bindings/py_radiation_flow.cpp&#10;        src_bindings/py_relative_vorticity.cpp&#10;        src_bindings/py_swirl_field.cpp&#10;        src_bindings/py_thermo_dynamics.cpp&#10;        src_bindings/py_time_evolution.cpp&#10;        src_bindings/py_vortex_knot_system.cpp&#10;        src_bindings/py_vortex_ring.cpp&#10;        src_bindings/py_vorticity_dynamics.cpp&#10;        src_bindings/py_vorticity_transport.cpp&#10;        src_bindings/py_FourierKnot.cpp)&#10;&#10;target_link_libraries(vambindings PRIVATE vamcore)&#10;target_include_directories(vambindings PRIVATE extern/pybind11/include)&#10;add_executable(test_frenet tests/test_frenet_helicity.cpp)&#10;target_link_libraries(test_frenet PRIVATE vamcore)&#10;&#10;&#10;# Install targets&#10;install(TARGETS vamcore vambindings&#10;        LIBRARY DESTINATION lib&#10;        ARCHIVE DESTINATION lib&#10;        RUNTIME DESTINATION bin)&#10;install(DIRECTORY include/ DESTINATION include)&#10;&#10;# === ✅ AUTO-COPY PYBIND MODULE TO PROJECT ROOT ===&#10;# After vambindings is built, copy it to ${CMAKE_SOURCE_DIR}&#10;# So you can easily import it from Python scripts in the root directory&#10;&#10;add_custom_command(TARGET vambindings POST_BUILD&#10;        COMMAND ${CMAKE_COMMAND} -E copy&#10;        $&lt;TARGET_FILE:vambindings&gt;&#10;        ${CMAKE_SOURCE_DIR}/$&lt;TARGET_FILE_NAME:vambindings&gt;&#10;        COMMAND ${CMAKE_COMMAND} -E copy&#10;        $&lt;TARGET_FILE:vambindings&gt;&#10;        ${CMAKE_SOURCE_DIR}/examples/$&lt;TARGET_FILE_NAME:vambindings&gt;&#10;        COMMAND ${CMAKE_COMMAND} -E copy&#10;        $&lt;TARGET_FILE:vambindings&gt;&#10;        ${CMAKE_SOURCE_DIR}/../VAM/$&lt;TARGET_FILE_NAME:vambindings&gt;&#10;        COMMENT &quot;Copied vambindings module to project root, examples/, and ../VAM/ for easy import&quot;&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/FourierKnot.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/FourierKnot.cpp" />
              <option name="updatedContent" value="#include &quot;FourierKnot.hpp&quot;&#10;#include &lt;fstream&gt;&#10;#include &lt;sstream&gt;&#10;#include &lt;cmath&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;numeric&gt;&#10;&#10;namespace vam {&#10;&#10;static inline double wrap_index(int i, int n) {&#10;    int r = i % n;&#10;    return (r &lt; 0) ? r + n : r;&#10;}&#10;&#10;std::vector&lt;FourierBlock&gt; FourierKnot::parse_fseries_multi(const std::string&amp; path) {&#10;    // ...existing code...&#10;    std::ifstream in(path);&#10;    std::vector&lt;FourierBlock&gt; blocks;&#10;    if (!in) return blocks;&#10;&#10;    FourierBlock cur;&#10;    auto flush_block = [&amp;]() {&#10;        if (!cur.a_x.empty()) {&#10;            blocks.emplace_back(cur);&#10;            cur = FourierBlock{};&#10;        }&#10;    };&#10;&#10;    std::string line;&#10;    while (std::getline(in, line)) {&#10;        // trim&#10;        while (!line.empty() &amp;&amp; (line.back()=='\r' || line.back()=='\n' || line.back()==' ' || line.back()=='\t')) line.pop_back();&#10;        if (line.empty()) { flush_block(); continue; }&#10;        if (line.size() &amp;&amp; line[0] == '%') {&#10;            flush_block();&#10;            cur.header = std::string(line.begin()+1, line.end());&#10;            // trim leading spaces&#10;            while (!cur.header.empty() &amp;&amp; (cur.header.front()==' ' || cur.header.front()=='\t')) cur.header.erase(cur.header.begin());&#10;            continue;&#10;        }&#10;        std::istringstream iss(line);&#10;        double ax,bx,ay,by,az,bz;&#10;        if (iss &gt;&gt; ax &gt;&gt; bx &gt;&gt; ay &gt;&gt; by &gt;&gt; az &gt;&gt; bz) {&#10;            cur.a_x.push_back(ax); cur.b_x.push_back(bx);&#10;            cur.a_y.push_back(ay); cur.b_y.push_back(by);&#10;            cur.a_z.push_back(az); cur.b_z.push_back(bz);&#10;        }&#10;    }&#10;    flush_block();&#10;    return blocks;&#10;}&#10;&#10;int FourierKnot::index_of_largest_block(const std::vector&lt;FourierBlock&gt;&amp; blocks) {&#10;    // ...existing code...&#10;    if (blocks.empty()) return -1;&#10;    int idx = 0;&#10;    size_t best = blocks[0].a_x.size();&#10;    for (int i=1;i&lt;(int)blocks.size();++i) {&#10;        size_t n = blocks[i].a_x.size();&#10;        if (n &gt; best) { best = n; idx = i; }&#10;    }&#10;    return idx;&#10;}&#10;&#10;std::vector&lt;Vec3&gt; FourierKnot::evaluate(const FourierBlock&amp; b, const std::vector&lt;double&gt;&amp; s) {&#10;    // ...existing code...&#10;    const int N = (int)b.a_x.size();&#10;    std::vector&lt;Vec3&gt; out(s.size(), {0.0,0.0,0.0});&#10;    for (size_t i=0;i&lt;s.size();++i) {&#10;        double si = s[i];&#10;        double x=0, y=0, z=0;&#10;        for (int j=0;j&lt;N;++j) {&#10;            int n = j+1;&#10;            double cn = std::cos(n*si), sn = std::sin(n*si);&#10;            x += b.a_x[j]*cn + b.b_x[j]*sn;&#10;            y += b.a_y[j]*cn + b.b_y[j]*sn;&#10;            z += b.a_z[j]*cn + b.b_z[j]*sn;&#10;        }&#10;        out[i] = {x,y,z};&#10;    }&#10;    return out;&#10;}&#10;&#10;std::vector&lt;Vec3&gt; FourierKnot::center_points(const std::vector&lt;Vec3&gt;&amp; pts) {&#10;    // ...existing code...&#10;    if (pts.empty()) return {};&#10;    double cx=0, cy=0, cz=0;&#10;    for (auto &amp;p: pts) { cx+=p[0]; cy+=p[1]; cz+=p[2]; }&#10;    cx/=pts.size(); cy/=pts.size(); cz/=pts.size();&#10;    std::vector&lt;Vec3&gt; out; out.reserve(pts.size());&#10;    for (auto &amp;p: pts) out.push_back({p[0]-cx, p[1]-cy, p[2]-cz});&#10;    return out;&#10;}&#10;&#10;std::vector&lt;double&gt; FourierKnot::curvature(const std::vector&lt;Vec3&gt;&amp; pts, double eps) {&#10;    // ...existing code...&#10;    const int n = (int)pts.size();&#10;    std::vector&lt;double&gt; k(n, 0.0);&#10;    if (n &lt; 3) return k;&#10;&#10;    auto minus = [](const Vec3&amp; a, const Vec3&amp; b)-&gt;Vec3 { return {a[0]-b[0], a[1]-b[1], a[2]-b[2]}; };&#10;    auto cross = [](const Vec3&amp; a, const Vec3&amp; b)-&gt;Vec3 {&#10;        return {a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]};&#10;    };&#10;    auto norm = [](const Vec3&amp; a)-&gt;double { return std::sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]); };&#10;&#10;    // Uniform parameterization, periodic central differences&#10;    for (int i=0;i&lt;n;++i) {&#10;        const Vec3&amp; pm = pts[(i-1+n)%n];&#10;        const Vec3&amp; p0 = pts[i];&#10;        const Vec3&amp; pp = pts[(i+1)%n];&#10;        // first derivative ~ (pp - pm)/2&#10;        Vec3 r1 = { (pp[0]-pm[0])*0.5, (pp[1]-pm[1])*0.5, (pp[2]-pm[2])*0.5 };&#10;        // second derivative ~ (pp - 2*p0 + pm)&#10;        Vec3 r2 = { pp[0]-2*p0[0]+pm[0], pp[1]-2*p0[1]+pm[1], pp[2]-2*p0[2]+pm[2] };&#10;        Vec3 cr = cross(r1, r2);&#10;        double num = norm(cr);&#10;        double den = std::pow(norm(r1), 3.0) + eps;&#10;        k[i] = num / den;&#10;    }&#10;    return k;&#10;}&#10;&#10;std::pair&lt;std::vector&lt;Vec3&gt;, std::vector&lt;double&gt;&gt;&#10;FourierKnot::load_knot(const std::string&amp; path, int nsamples) {&#10;    // ...existing code...&#10;    auto blocks = parse_fseries_multi(path);&#10;    int idx = index_of_largest_block(blocks);&#10;    if (idx &lt; 0) return {{}, {}};&#10;    std::vector&lt;double&gt; s(nsamples);&#10;    const double twoPi = 6.2831853071795864769;&#10;    for (int i=0;i&lt;nsamples;++i) s[i] = twoPi * double(i) / double(nsamples-1);&#10;    auto pts = center_points(evaluate(blocks[idx], s));&#10;    auto kap = curvature(pts);&#10;    return {pts, kap};&#10;}&#10;&#10;} // namespace vam&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/FourierKnot.hpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/FourierKnot.hpp" />
              <option name="updatedContent" value="#pragma once&#10;#include &lt;array&gt;&#10;#include &lt;string&gt;&#10;#include &lt;vector&gt;&#10;&#10;namespace vam {&#10;&#10;using Vec3 = std::array&lt;double, 3&gt;;&#10;&#10;struct FourierBlock {&#10;    std::string header;                 // optional header (may be empty)&#10;    std::vector&lt;double&gt; a_x, b_x;&#10;    std::vector&lt;double&gt; a_y, b_y;&#10;    std::vector&lt;double&gt; a_z, b_z;&#10;};&#10;&#10;class FourierKnot {&#10;public:&#10;    // Parse a .fseries file into blocks. Each block is separated by either a '%' header&#10;    // or by a blank line. Lines contain 6 doubles: a_x b_x a_y b_y a_z b_z&#10;    static std::vector&lt;FourierBlock&gt; parse_fseries_multi(const std::string&amp; path);&#10;&#10;    // Choose the block with the largest number of harmonics&#10;    static int index_of_largest_block(const std::vector&lt;FourierBlock&gt;&amp; blocks);&#10;&#10;    // Evaluate r(s) for a block on samples s (radians in [0,2π])&#10;    static std::vector&lt;Vec3&gt; evaluate(const FourierBlock&amp; block, const std::vector&lt;double&gt;&amp; s);&#10;&#10;    // Center points at their centroid and return centered points&#10;    static std::vector&lt;Vec3&gt; center_points(const std::vector&lt;Vec3&gt;&amp; pts);&#10;&#10;    // Discrete curvature from points using central differences (periodic curve)&#10;    static std::vector&lt;double&gt; curvature(const std::vector&lt;Vec3&gt;&amp; pts, double eps = 1e-8);&#10;&#10;    // Convenience: load file, pick largest block, evaluate on ns samples in [0,2π],&#10;    // center the result and return (points, curvature)&#10;    static std::pair&lt;std::vector&lt;Vec3&gt;, std::vector&lt;double&gt;&gt;&#10;    load_knot(const std::string&amp; path, int nsamples);&#10;};&#10;&#10;} // namespace vam&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src_bindings/module_vam.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src_bindings/module_vam.cpp" />
              <option name="originalContent" value="// bindings/py_vam.cpp&#10;#include &lt;pybind11/pybind11.h&gt;&#10;&#10;namespace py = pybind11;&#10;&#10;// Forward declaration only!&#10;void bind_biot_savart(py::module_&amp; m);&#10;void bind_fluid_dynamics(py::module_ &amp;m);&#10;void bind_fluid_rotation(py::module_ &amp;m);&#10;void bind_frenet_helicity(py::module_&amp; m);&#10;void bind_gravity_timefield(py::module_&amp; m);&#10;void bind_kinetic_energy(py::module_&amp; m);&#10;void bind_knot_dynamics(py::module_&amp; m);&#10;void bind_potential_flow(py::module_&amp; m);&#10;void bind_potential_timefield(py::module_&amp; m);&#10;void bind_pressure_field(py::module_&amp; m);&#10;void bind_radiation_flow(py::module_&amp; m);&#10;void bind_relative_vorticity(py::module_&amp; m);&#10;void bind_swirl_field(py::module_&amp; m);&#10;void bind_thermo_dynamics(py::module_&amp; m);&#10;void bind_time_evolution(py::module_&amp; m);&#10;void bind_vortex_knot_system(py::module_&amp; m);&#10;void bind_vortex_ring(py::module_&amp; m);&#10;void bind_vorticity_dynamics(py::module_&amp; m);&#10;void bind_vorticity_transport(py::module_&amp; m);&#10;&#10;&#10;PYBIND11_MODULE(vambindings, m) {&#10;  m.doc() = &quot;VAM Core Bindings&quot;;&#10;  bind_biot_savart(m);&#10;  bind_fluid_dynamics(m);&#10;  bind_fluid_rotation(m);&#10;  bind_frenet_helicity(m);&#10;  bind_gravity_timefield(m);&#10;  bind_kinetic_energy(m);&#10;  bind_knot_dynamics(m);&#10;  bind_potential_flow(m);&#10;  bind_potential_timefield(m);&#10;  bind_pressure_field(m);&#10;  bind_radiation_flow(m);&#10;  bind_relative_vorticity(m);&#10;  bind_swirl_field(m);&#10;  bind_thermo_dynamics(m);&#10;  bind_time_evolution(m);&#10;  bind_vortex_knot_system(m);&#10;  bind_vortex_ring(m);&#10;  bind_vorticity_dynamics(m);&#10;  bind_vorticity_transport(m);&#10;}&#10;" />
              <option name="updatedContent" value="// bindings/py_vam.cpp&#10;#include &lt;pybind11/pybind11.h&gt;&#10;&#10;namespace py = pybind11;&#10;&#10;// Forward declaration only!&#10;void bind_biot_savart(py::module_&amp; m);&#10;void bind_fluid_dynamics(py::module_ &amp;m);&#10;void bind_fluid_rotation(py::module_ &amp;m);&#10;void bind_frenet_helicity(py::module_&amp; m);&#10;void bind_gravity_timefield(py::module_&amp; m);&#10;void bind_kinetic_energy(py::module_&amp; m);&#10;void bind_knot_dynamics(py::module_&amp; m);&#10;void bind_potential_flow(py::module_&amp; m);&#10;void bind_potential_timefield(py::module_&amp; m);&#10;void bind_pressure_field(py::module_&amp; m);&#10;void bind_radiation_flow(py::module_&amp; m);&#10;void bind_relative_vorticity(py::module_&amp; m);&#10;void bind_swirl_field(py::module_&amp; m);&#10;void bind_thermo_dynamics(py::module_&amp; m);&#10;void bind_time_evolution(py::module_&amp; m);&#10;void bind_vortex_knot_system(py::module_&amp; m);&#10;void bind_vortex_ring(py::module_&amp; m);&#10;void bind_vorticity_dynamics(py::module_&amp; m);&#10;void bind_vorticity_transport(py::module_&amp; m);&#10;void bind_fourier_knot(py::module_&amp; m); // Forward declaration&#10;&#10;&#10;PYBIND11_MODULE(vambindings, m) {&#10;  m.doc() = &quot;VAM Core Bindings&quot;;&#10;  bind_biot_savart(m);&#10;  bind_fluid_dynamics(m);&#10;  bind_fluid_rotation(m);&#10;  bind_frenet_helicity(m);&#10;  bind_gravity_timefield(m);&#10;  bind_kinetic_energy(m);&#10;  bind_knot_dynamics(m);&#10;  bind_potential_flow(m);&#10;  bind_potential_timefield(m);&#10;  bind_pressure_field(m);&#10;  bind_radiation_flow(m);&#10;  bind_relative_vorticity(m);&#10;  bind_swirl_field(m);&#10;  bind_thermo_dynamics(m);&#10;  bind_time_evolution(m);&#10;  bind_vortex_knot_system(m);&#10;  bind_vortex_ring(m);&#10;  bind_vorticity_dynamics(m);&#10;  bind_vorticity_transport(m);&#10;  bind_fourier_knot(m); // Binding call&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src_bindings/py_FourierKnot.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src_bindings/py_FourierKnot.cpp" />
              <option name="updatedContent" value="#include &lt;pybind11/pybind11.h&gt;&#10;#include &lt;pybind11/stl.h&gt;&#10;#include &quot;../src/FourierKnot.hpp&quot;&#10;&#10;namespace py = pybind11;&#10;using vam::FourierBlock;&#10;using vam::FourierKnot;&#10;using vam::Vec3;&#10;&#10;void bind_fourier_knot(py::module_&amp; m) {&#10;    py::class_&lt;FourierBlock&gt;(m, &quot;FourierBlock&quot;)&#10;        .def(py::init&lt;&gt;())&#10;        .def_readwrite(&quot;header&quot;, &amp;FourierBlock::header)&#10;        .def_readwrite(&quot;a_x&quot;, &amp;FourierBlock::a_x)&#10;        .def_readwrite(&quot;b_x&quot;, &amp;FourierBlock::b_x)&#10;        .def_readwrite(&quot;a_y&quot;, &amp;FourierBlock::a_y)&#10;        .def_readwrite(&quot;b_y&quot;, &amp;FourierBlock::b_y)&#10;        .def_readwrite(&quot;a_z&quot;, &amp;FourierBlock::a_z)&#10;        .def_readwrite(&quot;b_z&quot;, &amp;FourierBlock::b_z);&#10;&#10;    m.def(&quot;parse_fseries_multi&quot;, &amp;FourierKnot::parse_fseries_multi,&#10;          py::arg(&quot;path&quot;), &quot;Parse a .fseries file into Fourier blocks.&quot;);&#10;&#10;    m.def(&quot;index_of_largest_block&quot;, &amp;FourierKnot::index_of_largest_block,&#10;          py::arg(&quot;blocks&quot;), &quot;Return index of block with most harmonics.&quot;);&#10;&#10;    m.def(&quot;evaluate_fourier_block&quot;, &amp;FourierKnot::evaluate,&#10;          py::arg(&quot;block&quot;), py::arg(&quot;s&quot;),&#10;          &quot;Evaluate r(s) for the given Fourier block.&quot;);&#10;&#10;    m.def(&quot;center_points&quot;, &amp;FourierKnot::center_points,&#10;          py::arg(&quot;points&quot;), &quot;Center points at their centroid.&quot;);&#10;&#10;    m.def(&quot;curvature_of_points&quot;, &amp;FourierKnot::curvature,&#10;          py::arg(&quot;points&quot;), py::arg(&quot;eps&quot;) = 1e-8,&#10;          &quot;Discrete curvature using periodic central differences.&quot;);&#10;&#10;    m.def(&quot;load_knot_from_fseries&quot;, &amp;FourierKnot::load_knot,&#10;          py::arg(&quot;path&quot;), py::arg(&quot;nsamples&quot;) = 1000,&#10;          &quot;Load, evaluate (largest block), center and compute curvature.&quot;);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>