#include "knot_dynamics.h"
#include "biot_savart.h"
#include <cmath>
#include <random>
#include <numeric>
#include <algorithm>
#include <optional>
#include <stdexcept>
#include <fstream>
#include <sstream>
#include <cctype>
#include <map>

// Include embedded knot files (generated by CMake during build)
// The file is always generated, so we can always include it
#include "knot_files_embedded.h"

namespace sst {

        double KnotDynamics::compute_writhe(const std::vector<Vec3>& X) {
                double W = 0.0;
                size_t N = X.size();
                for (size_t i = 0; i < N - 1; ++i) {
                        for (size_t j = i + 1; j < N - 1; ++j) {
                                Vec3 r = diff(X[i], X[j]);
                                double r_norm = norm(r);
                                if (r_norm < 1e-6) continue;
                                Vec3 t1 = diff(X[i+1], X[i]);
                                Vec3 t2 = diff(X[j+1], X[j]);
                                W += dot(cross(t1, t2), r) / (r_norm * r_norm * r_norm);
                        }
                }
                return W / (2.0 * M_PI);
        }

        int KnotDynamics::compute_linking_number(const std::vector<Vec3>& X, const std::vector<Vec3>& Y) {
                double Lk = 0.0;
                size_t N = X.size(), M = Y.size();
                for (size_t i = 0; i < N - 1; ++i) {
                        Vec3 xi = X[i];
                        Vec3 dx = diff(X[i+1], xi);
                        for (size_t j = 0; j < M - 1; ++j) {
                                Vec3 yj = Y[j];
                                Vec3 dy = diff(Y[j+1], yj);
                                Vec3 r = diff(xi, yj);
                                double r_norm = norm(r);
                                if (r_norm < 1e-6) continue;
                                Lk += dot(cross(dx, dy), r) / (r_norm * r_norm * r_norm);
                        }
                }
                return static_cast<int>(std::round(Lk / (4.0 * M_PI)));
        }

        double KnotDynamics::compute_twist(const std::vector<Vec3>& T, const std::vector<Vec3>& B) {
                double Tw = 0.0;
                size_t N = T.size();
                for (size_t i = 1; i < N - 1; ++i) {
                        Vec3 dB = diff(B[i+1], B[i-1]);
                        Vec3 dB_ds = {dB[0]/2.0, dB[1]/2.0, dB[2]/2.0};
                        Tw += dot(cross(T[i], dB_ds), B[i]);
                }
                return Tw / (2.0 * M_PI);
        }

        double KnotDynamics::compute_centerline_helicity(const std::vector<Vec3>& curve,
                                                                           const std::vector<Vec3>& tangent) {
                return compute_writhe(curve); // Simplified: H_cl ~ Wr for single loop
        }

        std::vector<std::pair<int, int>> KnotDynamics::detect_reconnection_candidates(
                        const std::vector<Vec3>& curve, double threshold) {
                std::vector<std::pair<int, int>> candidates;
                size_t N = curve.size();
                for (size_t i = 0; i < N; ++i) {
                        for (size_t j = i + 5; j < N; ++j) { // Skip close neighbors
                                Vec3 d = diff(curve[i], curve[j]);
                                if (norm(d) < threshold) {
                                        candidates.emplace_back(i, j);
                                }
                        }
                }
                return candidates;
        }

        // Fourier series evaluation (from heavy_knot)
        KnotDynamics::FourierResult KnotDynamics::evaluate_fourier_series(
                const std::vector<std::array<double, 6>>& coeffs,
                const std::vector<double>& t_vals) {
                size_t N = coeffs.size();
                size_t T = t_vals.size();
                FourierResult result;
                result.positions.resize(T);
                result.tangents.resize(T);

                for (size_t ti = 0; ti < T; ++ti) {
                        double t = t_vals[ti];
                        Vec3 r = {0, 0, 0}, r_t = {0, 0, 0};

                        for (size_t n = 0; n < N; ++n) {
                                double nt = n * t;
                                double cos_nt = std::cos(nt), sin_nt = std::sin(nt);
                                auto& c = coeffs[n];

                                r[0] += c[0]*cos_nt + c[1]*sin_nt;
                                r[1] += c[2]*cos_nt + c[3]*sin_nt;
                                r[2] += c[4]*cos_nt + c[5]*sin_nt;

                                if (n > 0) {
                                        r_t[0] += -n * c[0]*sin_nt + n * c[1]*cos_nt;
                                        r_t[1] += -n * c[2]*sin_nt + n * c[3]*cos_nt;
                                        r_t[2] += -n * c[4]*sin_nt + n * c[5]*cos_nt;
                                }
                        }

                        result.positions[ti] = r;
                        result.tangents[ti] = r_t;
                }
                return result;
        }

        // Writhe computation using Gauss integral with tangents (from heavy_knot)
        double KnotDynamics::writhe_gauss_curve(
                const std::vector<Vec3>& r,
                const std::vector<Vec3>& r_t) {
                const double pi = 3.141592653589793;
                size_t M = r.size();
                double sum = 0.0;
                double dt = 2 * pi / M;

                for (size_t i = 0; i < M; ++i) {
                        for (size_t j = 0; j < M; ++j) {
                                if (i == j) continue;
                                Vec3 dR = {
                                        r[i][0] - r[j][0],
                                        r[i][1] - r[j][1],
                                        r[i][2] - r[j][2]
                                };
                                double dist = std::sqrt(dR[0]*dR[0] + dR[1]*dR[1] + dR[2]*dR[2]);
                                if (dist < 1e-6) continue;

                                Vec3 Ti = r_t[i];
                                Vec3 Tj = r_t[j];
                                Vec3 cross = {
                                        Ti[1]*Tj[2] - Ti[2]*Tj[1],
                                        Ti[2]*Tj[0] - Ti[0]*Tj[2],
                                        Ti[0]*Tj[1] - Ti[1]*Tj[0]
                                };
                                double dot = cross[0]*dR[0] + cross[1]*dR[1] + cross[2]*dR[2];
                                sum += dot / (dist*dist*dist);
                        }
                }
                return (dt*dt * sum) / (4 * pi);
        }

        // Estimate crossing number from projections (from heavy_knot)
        int KnotDynamics::estimate_crossing_number(
                const std::vector<Vec3>& r,
                int directions,
                int seed) {
                size_t M = r.size();
                std::mt19937 gen(seed);
                std::normal_distribution<> d(0.0, 1.0);

                int min_cross = M*M;

                for (int d_iter = 0; d_iter < directions; ++d_iter) {
                        Vec3 w = {d(gen), d(gen), d(gen)};
                        double norm_w = std::sqrt(w[0]*w[0] + w[1]*w[1] + w[2]*w[2]);
                        for (auto& x : w) x /= norm_w + 1e-12;

                        Vec3 tmp = {1,0,0};
                        if (std::abs(w[0]) > 0.9) tmp = {0,1,0};

                        Vec3 u = {
                                w[1]*tmp[2] - w[2]*tmp[1],
                                w[2]*tmp[0] - w[0]*tmp[2],
                                w[0]*tmp[1] - w[1]*tmp[0]
                        };
                        double norm_u = std::sqrt(u[0]*u[0] + u[1]*u[1] + u[2]*u[2]);
                        for (auto& x : u) x /= norm_u + 1e-12;

                        Vec3 v = {
                                w[1]*u[2] - w[2]*u[1],
                                w[2]*u[0] - w[0]*u[2],
                                w[0]*u[1] - w[1]*u[0]
                        };

                        using Vec2 = std::array<double, 2>;
                        std::vector<Vec2> proj(M);
                        for (size_t i = 0; i < M; ++i) {
                                proj[i] = {r[i][0]*u[0] + r[i][1]*u[1] + r[i][2]*u[2],
                                           r[i][0]*v[0] + r[i][1]*v[1] + r[i][2]*v[2]};
                        }

                        int count = 0;
                        for (size_t i = 0; i < M; ++i) {
                                auto p1 = proj[i], p2 = proj[(i+1)%M];
                                for (size_t j = i+2; j < M; ++j) {
                                        if (j == (i-1+M)%M) continue;
                                        auto q1 = proj[j], q2 = proj[(j+1)%M];

                                        auto orient = [](const auto& a, const auto& b, const auto& c) {
                                                return (b[0]-a[0])*(c[1]-a[1]) - (b[1]-a[1])*(c[0]-a[0]);
                                        };
                                        double o1 = orient(p1,p2,q1);
                                        double o2 = orient(p1,p2,q2);
                                        double o3 = orient(q1,q2,p1);
                                        double o4 = orient(q1,q2,p2);
                                        if ((o1*o2 < 0) && (o3*o4 < 0)) ++count;
                                }
                        }

                        if (count < min_cross) min_cross = count;
                }

                return min_cross;
        }

        // Planar diagram from curve (from knot_pd)
        // Helper functions
        static inline double dot3(const Vec3& a, const Vec3& b){
                return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
        }
        static inline Vec3 cross3(const Vec3& a, const Vec3& b){
                return { a[1]*b[2]-a[2]*b[1],
                         a[2]*b[0]-a[0]*b[2],
                         a[0]*b[1]-a[1]*b[0] };
        }
        static inline double norm3(const Vec3& a){ return std::sqrt(dot3(a,a)); }

        static inline Vec3 unit_random_dir(std::mt19937& rng){
                std::normal_distribution<double> N(0.0,1.0);
                Vec3 v{N(rng),N(rng),N(rng)};
                const double n = norm3(v) + 1e-18;
                return {v[0]/n, v[1]/n, v[2]/n};
        }

        static inline void orthonormal_basis(const Vec3& n, Vec3& u, Vec3& v){
                const Vec3 a = (std::abs(n[0]) < 0.9) ? Vec3{1.0,0.0,0.0} : Vec3{0.0,1.0,0.0};
                u = cross3(n, a);
                const double un = norm3(u) + 1e-18;
                u = {u[0]/un, u[1]/un, u[2]/un};
                v = cross3(n, u);
        }

        using Vec2 = std::array<double, 2>;
        static inline void project_curve(const std::vector<Vec3>& P3,
                                         const Vec3& n,
                                         std::vector<Vec2>& P2,
                                         std::vector<double>& D)
        {
                Vec3 u, v;
                orthonormal_basis(n, u, v);
                const size_t N = P3.size();
                P2.resize(N);
                D.resize(N);
                for(size_t i=0;i<N;++i){
                        const Vec3& p = P3[i];
                        P2[i] = { dot3(p,u), dot3(p,v) };
                        D[i]  =  dot3(p,n);
                }
        }

        static inline std::optional<std::pair<double,double>>
        seg_intersection(const Vec2& p1, const Vec2& p2,
                         const Vec2& q1, const Vec2& q2,
                         double eps = 1e-12)
        {
                const double x1=p1[0], y1=p1[1];
                const double x2=p2[0], y2=p2[1];
                const double x3=q1[0], y3=q1[1];
                const double x4=q2[0], y4=q2[1];
                const double den = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4);
                if(std::abs(den) < eps) return std::nullopt;

                const double lam = ((x1-x3)*(y3-y4) - (y1-y3)*(x3-x4)) / den;
                const double mu  = ((x1-x3)*(y1-y2) - (y1-y3)*(x1-x2)) / den;

                if(lam <= eps || lam >= 1.0-eps) return std::nullopt;
                if(mu  <= eps || mu  >= 1.0-eps) return std::nullopt;
                return std::make_pair(lam, mu);
        }

        static std::vector<KnotDynamics::Crossing> build_pd_from_projection(
                const std::vector<Vec2>& P2,
                const std::vector<double>& D,
                double min_angle_deg,
                double depth_tol)
        {
                const int N = static_cast<int>(P2.size());
                struct CrossingGeom { int i,j; double lam,mu; bool over_i; };
                std::vector<CrossingGeom> crosses;

                for(int i=0;i<N;++i){
                        const Vec2& p1 = P2[i];
                        const Vec2& p2 = P2[(i+1)%N];
                        for(int j=i+2;j<N;++j){
                                if(j==i || j==(i-1+N)%N || (i==0 && j==N-1)) continue;
                                const Vec2& q1 = P2[j];
                                const Vec2& q2 = P2[(j+1)%N];
                                auto ans = seg_intersection(p1,p2,q1,q2);
                                if(!ans) continue;

                                const double lam = ans->first, mu = ans->second;
                                const double Di = D[i] + lam*(D[(i+1)%N]-D[i]);
                                const double Dj = D[j] + mu*(D[(j+1)%N]-D[j]);
                                if(std::abs(Di - Dj) < depth_tol) continue;

                                const double dxi = p2[0]-p1[0], dyi = p2[1]-p1[1];
                                const double dxj = q2[0]-q1[0], dyj = q2[1]-q1[1];
                                const double dotv = dxi*dxj + dyi*dyj;
                                const double ni = std::hypot(dxi, dyi) + 1e-18;
                                const double nj = std::hypot(dxj, dyj) + 1e-18;
                                double cosang = dotv/(ni*nj);
                                cosang = std::max(-1.0, std::min(1.0, cosang));
                                const double ang = std::acos(std::abs(cosang))*180.0/M_PI;
                                if(ang < min_angle_deg) continue;

                                crosses.push_back({i,j,lam,mu,(Di>Dj)});
                        }
                }
                if(crosses.empty()) throw std::runtime_error("No crossings detected (projection not generic).");

                struct Event { double s; int cross_id; bool over; int in_lab; int out_lab; };
                std::vector<Event> ev;
                ev.reserve(crosses.size()*2);
                for(int cid=0; cid<(int)crosses.size(); ++cid){
                        const auto& c = crosses[cid];
                        ev.push_back({ (c.i + c.lam)/double(N), cid,  c.over_i, 0,0 });
                        ev.push_back({ (c.j + c.mu )/double(N), cid, !c.over_i, 0,0 });
                }
                std::sort(ev.begin(), ev.end(), [](const Event& a, const Event& b){ return a.s < b.s; });
                for(size_t k=1;k<ev.size();++k){
                        if(std::abs(ev[k].s - ev[k-1].s) < 1e-12) ev[k].s += 1e-9;
                }

                const int L = static_cast<int>(ev.size());
                for(int idx=0; idx<L; ++idx){
                        ev[idx].in_lab  = (idx>0 ? idx : L);
                        ev[idx].out_lab = (idx+1<=L ? idx+1 : 1);
                }

                std::vector<KnotDynamics::Crossing> pd; pd.reserve(crosses.size());
                for(int cid=0; cid<(int)crosses.size(); ++cid){
                        int a=-1,b=-1,c=-1,d=-1;
                        for(const auto& e : ev){
                                if(e.cross_id != cid) continue;
                                if(e.over){ b = e.in_lab; d = e.out_lab; }
                                else      { a = e.in_lab; c = e.out_lab; }
                        }
                        if(a>0 && b>0 && c>0 && d>0) pd.push_back({a,b,c,d});
                }

                std::vector<int> counts(L+1,0);
                for(const auto& t : pd){ for(int lab : t) counts[lab]++; }
                for(int lab=1; lab<=L; ++lab){
                        if(counts[lab] != 2)
                                throw std::runtime_error("PD validation failed (labels must appear exactly twice).");
                }
                return pd;
        }

        KnotDynamics::PD KnotDynamics::pd_from_curve(
                const std::vector<Vec3>& P3,
                int tries,
                unsigned int seed,
                double min_angle_deg,
                double depth_tol)
        {
                if(P3.size() < 4) throw std::invalid_argument("pd_from_curve: need at least 4 points");
                std::mt19937 rng(seed);
                PD best; int best_score = -1;

                for(int t=0; t<tries; ++t){
                        const Vec3 n = unit_random_dir(rng);
                        std::vector<Vec2> P2; std::vector<double> D;
                        project_curve(P3, n, P2, D);
                        try{
                                PD pd = build_pd_from_projection(P2, D, min_angle_deg, depth_tol);
                                const int score = (int)pd.size();
                                if(score > best_score){ best_score = score; best = std::move(pd); }
                        }catch(...){ /* try next */ }
                }
                if(best_score < 0) throw std::runtime_error("Failed to extract PD from any projection.");
                return best;
        }

        // Biot-Savart and helicity calculation wrappers
        std::vector<Vec3> KnotDynamics::compute_biot_savart_velocity_grid(
                const std::vector<Vec3>& curve,
                const std::vector<Vec3>& grid_points) {
                return BiotSavart::computeVelocity(curve, grid_points);
        }

        std::vector<Vec3> KnotDynamics::compute_vorticity_grid(
                const std::vector<Vec3>& velocity,
                const std::array<int, 3>& shape,
                double spacing) {
                return BiotSavart::computeVorticity(velocity, shape, spacing);
        }

        std::vector<Vec3> KnotDynamics::extract_interior_field(
                const std::vector<Vec3>& field,
                const std::array<int, 3>& shape,
                int margin) {
                return BiotSavart::extractInterior(field, shape, margin);
        }

        std::tuple<double, double, double> KnotDynamics::compute_helicity_invariants(
                const std::vector<Vec3>& v_sub,
                const std::vector<Vec3>& w_sub,
                const std::vector<double>& r_sq) {
                return BiotSavart::computeInvariants(v_sub, w_sub, r_sq);
        }

        std::tuple<double, double, double> KnotDynamics::compute_helicity_from_fourier_block(
                const FourierBlock& block,
                int grid_size,
                double spacing,
                int interior_margin,
                int nsamples) {
                // Evaluate Fourier block to get knot points
                std::vector<double> s(nsamples);
                const double twoPi = 2.0 * M_PI;
                for (int i = 0; i < nsamples; ++i) {
                        s[i] = twoPi * double(i) / double(nsamples - 1);
                }
                std::vector<Vec3> curve = FourierKnot::evaluate(block, s);
                curve = FourierKnot::center_points(curve);

                // Create grid (matching Python: spacing * (np.arange(grid_size) - grid_size // 2))
                std::vector<Vec3> grid_points;
                grid_points.reserve(grid_size * grid_size * grid_size);
                const int half_grid = grid_size / 2;  // Integer division to match Python //
                for (int i = 0; i < grid_size; ++i) {
                        for (int j = 0; j < grid_size; ++j) {
                                for (int k = 0; k < grid_size; ++k) {
                                        double x = spacing * (i - half_grid);
                                        double y = spacing * (j - half_grid);
                                        double z = spacing * (k - half_grid);
                                        grid_points.push_back({x, y, z});
                                }
                        }
                }

                // Compute velocity on grid
                std::vector<Vec3> velocity = BiotSavart::computeVelocity(curve, grid_points);

                // Compute vorticity
                std::array<int, 3> shape = {grid_size, grid_size, grid_size};
                std::vector<Vec3> vorticity = BiotSavart::computeVorticity(velocity, shape, spacing);

                // Extract interior fields
                std::vector<Vec3> v_sub = BiotSavart::extractInterior(velocity, shape, interior_margin);
                std::vector<Vec3> w_sub = BiotSavart::extractInterior(vorticity, shape, interior_margin);

                // Compute r_sq for interior points (matching Python interior_vals)
                std::vector<double> r_sq;
                r_sq.reserve(v_sub.size());
                const int interior_size = grid_size - 2 * interior_margin;
                for (int i = 0; i < interior_size; ++i) {
                        for (int j = 0; j < interior_size; ++j) {
                                for (int k = 0; k < interior_size; ++k) {
                                        double x = spacing * (i + interior_margin - half_grid);
                                        double y = spacing * (j + interior_margin - half_grid);
                                        double z = spacing * (k + interior_margin - half_grid);
                                        r_sq.push_back(x*x + y*y + z*z);
                                }
                        }
                }

                // Compute invariants
                return BiotSavart::computeInvariants(v_sub, w_sub, r_sq);
        }

        // Fourier knot implementation (from fourier_knot.cpp)
        std::vector<FourierBlock> FourierKnot::parse_fseries_multi(const std::string& path) {
                std::ifstream in(path);
                std::vector<FourierBlock> blocks;
                if (!in) return blocks;

                FourierBlock cur;
                auto flush_block = [&]() {
                        if (!cur.a_x.empty()) {
                                blocks.emplace_back(cur);
                                cur = FourierBlock{};
                        }
                };

                std::string line;
                while (std::getline(in, line)) {
                        // trim
                        while (!line.empty() && (line.back()=='\r' || line.back()=='\n' || line.back()==' ' || line.back()=='\t')) line.pop_back();
                        if (line.empty()) { flush_block(); continue; }
                        if (line.size() && line[0] == '%') {
                                flush_block();
                                cur.header = std::string(line.begin()+1, line.end());
                                // trim leading spaces
                                while (!cur.header.empty() && (cur.header.front()==' ' || cur.header.front()=='\t')) cur.header.erase(cur.header.begin());
                                continue;
                        }
                        std::istringstream iss(line);
                        double ax,bx,ay,by,az,bz;
                        if (iss >> ax >> bx >> ay >> by >> az >> bz) {
                                cur.a_x.push_back(ax); cur.b_x.push_back(bx);
                                cur.a_y.push_back(ay); cur.b_y.push_back(by);
                                cur.a_z.push_back(az); cur.b_z.push_back(bz);
                        }
                }
                flush_block();
                return blocks;
        }

        std::vector<FourierBlock> FourierKnot::parse_fseries_from_string(const std::string& content) {
                std::istringstream in(content);
                std::vector<FourierBlock> blocks;
                
                FourierBlock cur;
                auto flush_block = [&]() {
                        if (!cur.a_x.empty()) {
                                blocks.emplace_back(cur);
                                cur = FourierBlock{};
                        }
                };

                std::string line;
                while (std::getline(in, line)) {
                        // trim
                        while (!line.empty() && (line.back()=='\r' || line.back()=='\n' || line.back()==' ' || line.back()=='\t')) line.pop_back();
                        if (line.empty()) { flush_block(); continue; }
                        if (line.size() && line[0] == '%') {
                                flush_block();
                                cur.header = std::string(line.begin()+1, line.end());
                                // trim leading spaces
                                while (!cur.header.empty() && (cur.header.front()==' ' || cur.header.front()=='\t')) cur.header.erase(cur.header.begin());
                                continue;
                        }
                        std::istringstream iss(line);
                        double ax,bx,ay,by,az,bz;
                        if (iss >> ax >> bx >> ay >> by >> az >> bz) {
                                cur.a_x.push_back(ax); cur.b_x.push_back(bx);
                                cur.a_y.push_back(ay); cur.b_y.push_back(by);
                                cur.a_z.push_back(az); cur.b_z.push_back(bz);
                        }
                }
                flush_block();
                return blocks;
        }

        int FourierKnot::index_of_largest_block(const std::vector<FourierBlock>& blocks) {
                if (blocks.empty()) return -1;
                int idx = 0;
                size_t best = blocks[0].a_x.size();
                for (int i=1;i<(int)blocks.size();++i) {
                        size_t n = blocks[i].a_x.size();
                        if (n > best) { best = n; idx = i; }
                }
                return idx;
        }

        std::vector<Vec3> FourierKnot::evaluate(const FourierBlock& b, const std::vector<double>& s) {
                const int N = (int)b.a_x.size();
                std::vector<Vec3> out(s.size(), {0.0,0.0,0.0});
                for (size_t i=0;i<s.size();++i) {
                        double si = s[i];
                        double x=0, y=0, z=0;
                        for (int j=0;j<N;++j) {
                                int n = j+1;
                                double cn = std::cos(n*si), sn = std::sin(n*si);
                                x += b.a_x[j]*cn + b.b_x[j]*sn;
                                y += b.a_y[j]*cn + b.b_y[j]*sn;
                                z += b.a_z[j]*cn + b.b_z[j]*sn;
                        }
                        out[i] = {x,y,z};
                }
                return out;
        }

        std::vector<Vec3> FourierKnot::center_points(const std::vector<Vec3>& pts) {
                if (pts.empty()) return {};
                double cx=0, cy=0, cz=0;
                for (auto &p: pts) { cx+=p[0]; cy+=p[1]; cz+=p[2]; }
                cx/=pts.size(); cy/=pts.size(); cz/=pts.size();
                std::vector<Vec3> out; out.reserve(pts.size());
                for (auto &p: pts) out.push_back({p[0]-cx, p[1]-cy, p[2]-cz});
                return out;
        }

        std::vector<double> FourierKnot::curvature(const std::vector<Vec3>& pts, double eps) {
                const int n = (int)pts.size();
                std::vector<double> k(n, 0.0);
                if (n < 3) return k;

                auto minus = [](const Vec3& a, const Vec3& b)->Vec3 { return {a[0]-b[0], a[1]-b[1], a[2]-b[2]}; };
                auto cross = [](const Vec3& a, const Vec3& b)->Vec3 {
                        return {a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]};
                };
                auto norm = [](const Vec3& a)->double { return std::sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]); };

                // Uniform parameterization, periodic central differences
                for (int i=0;i<n;++i) {
                        const Vec3& pm = pts[(i-1+n)%n];
                        const Vec3& p0 = pts[i];
                        const Vec3& pp = pts[(i+1)%n];
                        // first derivative ~ (pp - pm)/2
                        Vec3 r1 = { (pp[0]-pm[0])*0.5, (pp[1]-pm[1])*0.5, (pp[2]-pm[2])*0.5 };
                        // second derivative ~ (pp - 2*p0 + pm)
                        Vec3 r2 = { pp[0]-2*p0[0]+pm[0], pp[1]-2*p0[1]+pm[1], pp[2]-2*p0[2]+pm[2] };
                        Vec3 cr = cross(r1, r2);
                        double num = norm(cr);
                        double den = std::pow(norm(r1), 3.0) + eps;
                        k[i] = num / den;
                }
                return k;
        }

        std::pair<std::vector<Vec3>, std::vector<double>>
        FourierKnot::load_knot(const std::string& path, int nsamples) {
                auto blocks = parse_fseries_multi(path);
                int idx = index_of_largest_block(blocks);
                if (idx < 0) return {{}, {}};
                std::vector<double> s(nsamples);
                const double twoPi = 6.2831853071795864769;
                for (int i=0;i<nsamples;++i) s[i] = twoPi * double(i) / double(nsamples-1);
                auto pts = center_points(evaluate(blocks[idx], s));
                auto kap = curvature(pts);
                return {pts, kap};
        }

        std::vector<FourierKnot::LoadedKnot>
        FourierKnot::load_all_knots(const std::vector<std::string>& paths, int nsamples) {
                std::vector<LoadedKnot> result;
                result.reserve(paths.size());

                for (const auto& path : paths) {
                        // Extract filename without extension
                        std::string name = path;
                        size_t last_slash = name.find_last_of("/\\");
                        if (last_slash != std::string::npos) {
                                name = name.substr(last_slash + 1);
                        }
                        size_t last_dot = name.find_last_of('.');
                        if (last_dot != std::string::npos) {
                                name = name.substr(0, last_dot);
                        }
                        // Remove 'knot' or 'Knot' from name (matching Python behavior)
                        std::string lower_name = name;
                        std::transform(lower_name.begin(), lower_name.end(), lower_name.begin(), ::tolower);
                        size_t pos = lower_name.find("knot");
                        if (pos != std::string::npos) {
                                name.erase(pos, 4);
                        }

                        // Load the knot
                        auto [pts, curv] = load_knot(path, nsamples);
                        if (!pts.empty()) {
                                LoadedKnot knot;
                                knot.name = name;
                                knot.points = std::move(pts);
                                knot.curvature = std::move(curv);
                                result.push_back(std::move(knot));
                        }
                }
                return result;
        }

        void FourierKnot::loadBlocks(const std::string& filename) {
                blocks.clear();
                std::ifstream file(filename);
                if (!file.is_open()) {
                        throw std::runtime_error("Cannot open file: " + filename);
                }

                Block current;
                std::string line;
                while (std::getline(file, line)) {
                        // trim
                        if (line.empty()) {
                                if (!current.a_x.empty()) {
                                        blocks.push_back(current);
                                        current = Block{};
                                }
                                continue;
                        }
                        if (line[0] == '%') {
                                if (!current.a_x.empty()) {
                                        blocks.push_back(current);
                                        current = Block{};
                                }
                                continue;
                        }

                        std::istringstream iss(line);
                        std::vector<double> parts;
                        double val;
                        while (iss >> val) parts.push_back(val);

                        if (parts.size() == 6) {
                                current.a_x.push_back(parts[0]);
                                current.b_x.push_back(parts[1]);
                                current.a_y.push_back(parts[2]);
                                current.b_y.push_back(parts[3]);
                                current.a_z.push_back(parts[4]);
                                current.b_z.push_back(parts[5]);
                        }
                }
                if (!current.a_x.empty()) {
                        blocks.push_back(current);
                }
        }

        void FourierKnot::selectMaxHarmonics() {
                if (blocks.empty()) {
                        throw std::runtime_error("No Fourier blocks loaded");
                }
                size_t maxSize = 0;
                size_t maxIdx = 0;
                for (size_t i = 0; i < blocks.size(); ++i) {
                        if (blocks[i].a_x.size() > maxSize) {
                                maxSize = blocks[i].a_x.size();
                                maxIdx = i;
                        }
                }
                activeBlock = blocks[maxIdx];
        }

        void FourierKnot::reconstruct(size_t N) {
                if (activeBlock.a_x.empty()) {
                        throw std::runtime_error("No active Fourier block selected");
                }
                points.clear();
                points.reserve(N);
                double step = 2.0 * M_PI / static_cast<double>(N);
                for (size_t i = 0; i < N; ++i) {
                        double s = step * static_cast<double>(i);
                        points.push_back(evalPoint(activeBlock, s));
                }
        }

        Vec3 FourierKnot::evalPoint(const Block& blk, double s) {
                double x = 0.0, y = 0.0, z = 0.0;
                size_t N = blk.a_x.size();
                for (size_t j = 0; j < N; ++j) {
                        auto n = static_cast<double>(j + 1);
                        double cs = std::cos(n * s);
                        double sn = std::sin(n * s);
                        x += blk.a_x[j] * cs + blk.b_x[j] * sn;
                        y += blk.a_y[j] * cs + blk.b_y[j] * sn;
                        z += blk.a_z[j] * cs + blk.b_z[j] * sn;
                }
                return Vec3{x, y, z};
        }

        // Vortex knot system implementation (from vortex_knot_system.cpp)
        VortexKnotSystem::VortexKnotSystem(double gamma) : circulation(gamma) {}

        void VortexKnotSystem::initialize_trefoil_knot(size_t resolution) {
                positions.clear();
                tangents.clear();
                positions.reserve(resolution);

                for (size_t i = 0; i < resolution; ++i) {
                        double s = 2.0 * M_PI * static_cast<double>(i) / static_cast<double>(resolution);
                        double x = (2.0 + std::cos(3.0 * s)) * std::cos(2.0 * s);
                        double y = (2.0 + std::cos(3.0 * s)) * std::sin(2.0 * s);
                        double z = std::sin(3.0 * s);
                        positions.push_back({x, y, z});
                }

                compute_tangents();
        }

        void VortexKnotSystem::initialize_figure8_knot(size_t resolution) {
                positions.clear();
                tangents.clear();
                positions.reserve(resolution);

                for (size_t i = 0; i < resolution; ++i) {
                        double s = 2.0 * M_PI * static_cast<double>(i) / static_cast<double>(resolution);
                        double x = (2.0 + std::cos(2.0 * s)) * std::cos(3.0 * s);
                        double y = (2.0 + std::cos(2.0 * s)) * std::sin(3.0 * s);
                        double z = std::sin(4.0 * s);
                        positions.push_back({x, y, z});
                }

                compute_tangents();
        }

        void VortexKnotSystem::compute_tangents() {
                tangents.resize(positions.size());
                size_t N = positions.size();
                for (size_t i = 0; i < N; ++i) {
                        const Vec3& prev = positions[(i + N - 1) % N];
                        const Vec3& next = positions[(i + 1) % N];
                        Vec3 tangent{
                                (next[0] - prev[0]) * 0.5,
                                (next[1] - prev[1]) * 0.5,
                                (next[2] - prev[2]) * 0.5
                        };
                        tangents[i] = tangent;
                }
        }

        std::string VortexKnotSystem::find_knot_file(const std::string& knot_id) {
                // Fallback: Try file system locations (for development or custom files)
                std::vector<std::string> search_paths = {
                        "src/knot_fseries",
                        "../src/knot_fseries",
                        "../../src/knot_fseries",
                        "../../../src/knot_fseries",
                        "knot_fseries",
                        "../knot_fseries",
                        "../../knot_fseries",
                };
                
                // Also try relative to executable/package location (for installed packages)
                search_paths.push_back("share/swirl_string_core/knot_fseries");
                #ifdef _WIN32
                // Windows: try common relative paths
                search_paths.push_back("../../share/swirl_string_core/knot_fseries");
                #else
                // Unix: try standard installation paths
                search_paths.push_back("../../share/swirl_string_core/knot_fseries");
                search_paths.push_back("/usr/local/share/swirl_string_core/knot_fseries");
                search_paths.push_back("/usr/share/swirl_string_core/knot_fseries");
                #endif

                std::string filename = "knot." + knot_id + ".fseries";
                
                for (const auto& base_path : search_paths) {
                        std::string full_path = base_path + "/" + filename;
                        std::ifstream test(full_path);
                        if (test.good()) {
                                return full_path;
                        }
                }
                
                throw std::runtime_error("Could not find .fseries file for knot: " + knot_id);
        }

        void VortexKnotSystem::initialize_knot_from_name(const std::string& knot_id, size_t resolution) {
                // First, try embedded files (compiled into the library)
                static std::map<std::string, std::string> embedded_files = sst::get_embedded_knot_files();
                auto it = embedded_files.find(knot_id);
                if (it != embedded_files.end() && !it->second.empty()) {
                        // Parse embedded content from string
                        std::vector<FourierBlock> blocks = FourierKnot::parse_fseries_from_string(it->second);
                        int idx = FourierKnot::index_of_largest_block(blocks);
                        if (idx >= 0) {
                                std::vector<double> s(static_cast<int>(resolution));
                                const double twoPi = 2.0 * M_PI;
                                for (size_t i = 0; i < resolution; ++i) {
                                        s[i] = twoPi * double(i) / double(resolution - 1);
                                }
                                positions = FourierKnot::center_points(FourierKnot::evaluate(blocks[idx], s));
                                compute_tangents();
                                return;
                        }
                }
                
                // Fallback: Try file system
                try {
                        std::string filepath = find_knot_file(knot_id);
                        auto [pts, curv] = FourierKnot::load_knot(filepath, static_cast<int>(resolution));
                        if (pts.empty()) {
                                throw std::runtime_error("Failed to load knot " + knot_id + " from " + filepath);
                        }
                        positions = std::move(pts);
                        compute_tangents();
                } catch (const std::exception& e) {
                        throw std::runtime_error("Could not initialize knot " + knot_id + 
                                                ": " + std::string(e.what()));
                }
        }

        void VortexKnotSystem::evolve(double dt, size_t steps) {
                for (size_t step = 0; step < steps; ++step) {
                        std::vector<Vec3> new_positions = positions;
                        for (size_t i = 0; i < positions.size(); ++i) {
                                Vec3 v = biot_savart_velocity(positions[i], positions, tangents, circulation);
                                for (int d = 0; d < 3; ++d) {
                                        new_positions[i][d] += dt * v[d];
                                }
                        }
                        positions = new_positions;
                        compute_tangents();
                }
        }

        const std::vector<Vec3>& VortexKnotSystem::get_positions() const {
                return positions;
        }

        const std::vector<Vec3>& VortexKnotSystem::get_tangents() const {
                return tangents;
        }

} // namespace sst